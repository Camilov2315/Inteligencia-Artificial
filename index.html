<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inteligencia Artificial</title>
</head>
<body>
    <h1> CLASE 1 INTELIGENCIA ARTIFICIAL 15/08/2024 </h1>
    <P>  EN ESTA CLASE APRENDIMOS FUNDAMENTOS DE LA INTELIGENCIA ARTIFICIAL, ADEMAS APRENDIMOS GITHUB</P>
    <br>
    <h2> TEMAS SUGUERIDOS:</h2>
    <img src="imagenes/imagen1.jpg" width=" 300" height="300">
    <p>  vimos que datos se repetían y buscamos graficar de cierto que nos brindara dicha información en una grafica de pastel</p>
<BR>
<H2> ACTIVIDADES SIMILARES:</H2>
   <img src="imagenes/ima2.jpg" width="300px" height="300px">
<p>  Se agruparon las actividades que eran similares y se contaron manualmente</p>
   <br>
   <h2> ACTIVIDADES SIMILARES:</h2>
   <img src="imagenes/ima3.jpg" width="300" height="300">
    <p>Elegimos la columna número 5 y sacamos las palabras repetidas con la ayuda de chatGPT y las rectificamos manualmente e hicimos lo mismo con las palabras únicas (que no se repetían)
        Luego último hicimos la suma de las palabras repetidas y también sacamos el número de palabras únicas y por último hicimos un gráfico circular 3D con los números de las palabras repetidas</p>
        <br>
        <H2> 22/08/ 20</H2>
        <img src="imagenes/Maching learning.jpg" width="300" height="300">
        <P> INTELIGENCIA ARTIFICIAL APRENDIMOS ACERCA DE ESTE CONCEPTO:  La inteligencia artificial es un campo de la ciencia relacionado con la creación de computadoras y máquinas que pueden razonar, aprender y actuar de una manera que normalmente requeriría inteligencia humana o que involucra datos cuya escala excede lo que los humanos pueden analizar.  </P>
        <p> El principio .fundamental de la IA es replicar, y luego superar, la forma en que los humanos perciben y reaccionan ante el mundo. Se está convirtiendo rápidamente en la piedra angular de la innovación. La IA, impulsada por varias formas de machine learning que reconocen patrones en los datos para permitir predicciones</p>

        <p> Aprendimos el concepto de algoritmos de busqueda onjunto de instrucciones que están diseñadas para localizar un elemento con ciertas propiedades dentro de una estructura de datos; </p>
        <br>
        <br>
        <h2> 29/08/2024</h2>
        <h3> REDES NEURONALES</h3>
        <img src="imagenes/redes neuronales.png" width="300" height="300">
        <P> El dia  Las redes neuronales son un tipo de modelo de aprendizaje automático inspirado en la estructura y función del cerebro humano. Estas redes están compuestas por capas de nodos o neuronas artificiales que se comunican entre sí a través de conexiones sinápticas. Al procesar grandes cantidades de datos, las redes neuronales pueden aprender patrones y relaciones complejas, lo que las hace ideales para tareas como el reconocimiento de imágenes, el procesamiento del lenguaje natural y la toma de decisiones. </P>
        <p> Una de las características más importantes de las redes neuronales es su capacidad para aprender y mejorar con el tiempo. Esto se logra a través de un proceso llamado "entrenamiento", en el que la red neuronal se expone a grandes cantidades de datos y se ajusta para minimizar el error entre sus predicciones y los resultados reales. Una vez entrenada, la red neuronal puede ser utilizada para hacer predicciones y tomar decisiones en situaciones nuevas y desconocidas.</p>
<br>
<br>
<h2> 12/08/2024 ..</h2>
<h3> EJERCICIO REDES NEURONALES</h3>
<p> nos adentramos en el mundo de las, redes neuronales en Google Colab, explorando cómo aplicar redes neuronales desde un único punto de entrada ingresando valores. Este viaje comenzó con la comprensión de los conceptos fundamentales de las redes neuronales </p>
<p> El proceso de entrenamiento de una red neuronal implica la exposición a grandes conjuntos de datos, permitiendo que la red ajuste sus pesos y mejore su precisión en tareas específicas, como el reconocimiento de patrones o la clasificación de imágenes. A medida que avanzamos en este aprendizaje, es fundamental dominar no solo la teoría detrás de las redes neuronales, sino también la práctica de implementarlas en entornos como Google Colab, donde la accesibilidad y la potencia de procesamiento se combinan para facilitar la experimentación y la innovación en el campo del aprendizaje automático. </p>
<img src="imagenes/neuronales.PNG" width="300" height="300">
<br>
<br>
<h2> parcial 26/09/2024</h2>
<p> punto 3 del parcial captura</p>
<img src="imagenes/comparacion.PNG" width="600" height="600">
<br>
<h2> punto 4</h3>
<p>comente que hace cada línea de código de acuerdo al vídeo: </p>
<img src="imagenes/punto4.PNG" width="600" height="600">
<br>
<br>
<h2>   RESULTADOS INTERESES 10/10/2024</h2>
<P> Resultado encuesta</P>
<img src="imagenes/resultado puntaje.PNG" width="600" height="600">
<br>
<img src="imagenes/resultado.PNG" width="600" height="600">
<br>
<img src="imagenes/resul.PNG" width="600" height="600">
<br>
<p> SEGUNDA ENCUESTA</p>
<img src="imagenes/segundaprueba.PNG" width="600" height="600">
<H2> SEGUNDO PARCIAL 2 CORTE - 24/10/2024</H2>
    <code>
        import itertools  # Importa la librería itertools, aunque no se utiliza en este código.

class Sentence():
    # Clase base para representar sentencias lógicas.  <br> <br>

    def evaluate(self, model):
        """Evalúa la sentencia lógica."""
        raise Exception("nothing to evaluate")  # Lanzar una excepción si se llama a esta función. <br> <br>

    def formula(self):
        """Devuelve la fórmula en forma de cadena que representa la sentencia lógica.""" <br> <br>
        return ""  # Retorna una cadena vacía por defecto.<br> <br>

    def symbols(self):
        """Devuelve un conjunto de todos los símbolos en la sentencia lógica."""<br> <br>
        return set()  # Retorna un conjunto vacío por defecto.<br> <br>

    @classmethod
    def validate(cls, sentence):<br> <br>
        """Valida que el objeto dado sea una instancia de Sentence."""<br> <br>
        if not isinstance(sentence, Sentence):<br> <br>
            raise TypeError("must be a logical sentence")  # Lanza TypeError si no lo es.<br> <br>

    @classmethod
    def parenthesize(cls, s):<br> <br>
        """Añade paréntesis a una expresión si no están ya presentes."""<br> <br>
        def balanced(s):<br> <br>
            """Verifica si una cadena tiene paréntesis balanceados."""<br> <br>
            count = 0  # Contador para paréntesis.<br> <br>
            for c in s:  # Itera sobre cada carácter de la cadena.<br> <br>
                if c == "(":
                    count += 1  # Incrementa si encuentra un paréntesis de apertura.
                elif c == ")":<br> <br>
                    if count <= 0:<br> <br>
                        return False  # Retorna False si encuentra un paréntesis de cierre sin par.<br> <br>
                    count -= 1  # Decrementa el contador al encontrar un cierre.<br> <br>
            return count == 0  # Retorna True si todos los paréntesis están balanceados.<br> <br>

        # Condiciones para determinar si se necesitan paréntesis.<br> <br>
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):<br> <br>
            return s  # Retorna la cadena original si ya está adecuadamente balanceada.
        else:<br> <br>
            return f"({s})"  # Añade paréntesis si no es necesario.<br> <br>

class Symbol(Sentence):<br> <br>
    # Clase que representa un símbolo en la lógica<br> <br>.

    def __init__(self, name):<br> <br>
        self.name = name  # Inicializa el símbolo con un nombre.<br> <br>

    def __eq__(self, other):<br> <br>
        return isinstance(other, Symbol) and self.name == other.name  # Comparación de igualdad.<br> <br>

    def __hash__(self):<br> <br>
        return hash(("symbol", self.name))  # Genera un hash para el símbolo.<br> <br>

    def __repr__(self):<br> <br>
        return self.name  # Representación del símbolo como su nombre.<br> <br>

    def evaluate(self, model):<br> <br>
        """Evalúa el símbolo en el modelo dado."""<br> <br>
        try:<br> <br>
            return bool(model[self.name])  # Retorna el valor booleano asociado al símbolo.
        except KeyError:<br> <br>
            raise EvaluationException(f"variable {self.name} not in model")  # Lanza excepción si el símbolo no está en el modelo.
            
    def formula(self):<br> <br>
        return self.name  # Retorna el nombre del símbolo como su fórmula.<br> <br>

    def symbols(self):<br> <br>
        return {self.name}  # Retorna un conjunto con el símbolo.

class Not(Sentence):<br> <br>
    # Clase que representa la negación de una sentencia.<br> <br>

    def __init__(self, operand):<br> <br>
        Sentence.validate(operand)  # Valida el operando.<br> <br>
        self.operand = operand  # Inicializa el operando.<br> <br>

    def __eq__(self, other):<br> <br>
        return isinstance(other, Not) and self.operand == other.operand  # Comparación de igualdad.<br> <br>

    def __hash__(self):<br> <br>
        return hash(("not", hash(self.operand)))  # Genera un hash para la negación.<br> <br>

    def __repr__(self):<br> <br>
        return f"Not({self.operand})"  # Representación de la negación.
        <br> <br>
    def evaluate(self, model):
        return not self.operand.evaluate(model)  # Evalúa la negación del operando.<br> <br>

    def formula(self):
        return "¬" + Sentence.parenthesize(self.operand.formula())  # Retorna la fórmula de la negación.<br> <br>

    def symbols(self):<br> <br>
        return self.operand.symbols()  # Retorna los símbolos del operando.<br> <br>

class And(Sentence):<br> <br>
    # Clase que representa la conjunción de varias sentencias.<br> <br>
    
    def __init__(self, *conjuncts):<br> <br>
        for conjunct in conjuncts:<br> <br>
            Sentence.validate(conjunct)  # Valida cada conjunción.<br> <br>
        self.conjuncts = list(conjuncts)  # Almacena las conjunciones.<br> <br>

    def __eq__(self, other):<br> <br>
        return isinstance(other, And) and self.conjuncts == other.conjuncts  # Comparación de igualdad.<br> <br>

    def __hash__(self):<br> <br>
        return hash(<br> <br>
            ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))
        )  # Genera un hash para la conjunción.<br> <br>

    def __repr__(self):<br> <br>
        conjunctions = ", ".join(
            [str(conjunct) for conjunct in self.conjuncts]<br> <br>
        )  # Crea una representación de las conjunciones.
        return f"And({conjunctions})"

    def add(self, conjunct):<br> <br>
        Sentence.validate(conjunct)  # Valida la nueva conjunción.<br> <br>
        self.conjuncts.append(conjunct)  # Agrega la conjunción.<br> <br>

    def evaluate(self, model):<br> <br>
        return all(conjunct.evaluate(model) for conjunct in self.conjuncts)  # Evalúa todas las conjunciones.<br> <br>

    def formula(self):
        if len(self.conjuncts) == 1:<br> <br>
            return self.conjuncts[0].formula()  # Retorna la fórmula si solo hay una conjunción.<br> <br>
        return " ∧ ".join([Sentence.parenthesize(conjunct.formula())<br> <br>
                           for conjunct in self.conjuncts])  # Retorna la fórmula de la conjunción.<br> <br>

    def symbols(self):<br> <br>
        return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])  # Retorna los símbolos de las conjunciones.<br> <br>

class Or(Sentence):
    # Clase que representa la disyunción de varias sentencias.<br> <br>
    <br> <br>
    def __init__(self, *disjuncts):
        for disjunct in disjuncts:<br> <br>
            Sentence.validate(disjunct)  # Valida cada disyunción.<br> <br>
        self.disjuncts = list(disjuncts)  # Almacena las disyunciones.<br> <br>

    def __eq__(self, other):
        return isinstance(other, Or) and self.disjuncts == other.disjuncts  # Comparación de igualdad.
        <br> <br>
    def __hash__(self):
        return hash(
            ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))
        )  # Genera un hash para la disyunción.<br> <br>

    def __repr__(self):<br> <br>
        disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])  # Crea una representación de las disyunciones.
        return f"Or({disjuncts})"
        <br> <br>
    def evaluate(self, model):<br> <br>
        return any(disjunct.evaluate(model) for disjunct in self.disjuncts)  # Evalúa si alguna disyunción es verdadera.<br> <br>

    def formula(self):
        if len(self.disjuncts) == 1:<br> <br>
            return self.disjuncts[0].formula()  # Retorna la fórmula si solo hay una disyunción.<br> <br>
        return " ∨  ".join([Sentence.parenthesize(disjunct.formula())<br> <br>
                            for disjunct in self.disjuncts])  # Retorna la fórmula de la disyunción.<br> <br>

    def symbols(self):<br> <br>
        return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])  # Retorna los símbolos de las disyunciones.<br> <br>

class Implication(Sentence):<br> <br>
    # Clase que representa una implicación.<br> <br>

    def __init__(self, antecedent, consequent):<br> <br>
        Sentence.validate(antecedent)  # Valida el antecedente.<br> <br>
        Sentence.validate(consequent)  # Valida el consecuente.<br> <br>
        self.antecedent = ante

    </code>
    <br>

    <h2> punto 6</h2>
    <pre><code>
        from logic import *

# Definición de los símbolos
rain = Symbol("rain")
bbc = Symbol("bbc")
unimayor = Symbol("unimayor")

# Conjunto de conocimiento
knowledge = And(
    Implication(Not(rain), bbc),            # Si no llueve, los estudiantes visitan BBC
    Or(bbc, unimayor),                      # Estudiantes visitan BBC o Unimayor
    Not(And(bbc, unimayor)),                # No visitan ambos lugares a la vez
    unimayor                                # Estudiantes visitaron Unimayor
)

# Inferencias
print("¿Qué podemos inferir acerca de BBC?:", model_check(knowledge, bbc))
print("¿Qué podemos inferir acerca del clima?:", model_check(knowledge, rain))

 </code> </pre>
    </body>
</html>
